<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>最佳实践 on Docker Docs</title>
    <link>/tags/best-practices/</link>
    <description>Recent content in 最佳实践 on Docker Docs</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="/tags/best-practices/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker Compose 中处理环境变量的最佳实践</title>
      <link>/compose/how-tos/environment-variables/best-practices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/compose/how-tos/environment-variables/best-practices/</guid>
      <description>&lt;h4 class=&#34; scroll-mt-20 flex items-center gap-2&#34; id=&#34;安全地处理敏感信息&#34;&gt;&#xA;  &lt;a class=&#34;text-black dark:text-white no-underline hover:underline&#34; href=&#34;#%e5%ae%89%e5%85%a8%e5%9c%b0%e5%a4%84%e7%90%86%e6%95%8f%e6%84%9f%e4%bf%a1%e6%81%af&#34;&gt;&#xA;    安全地处理敏感信息&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;谨慎在环境变量中包含敏感数据。考虑使用 &lt;a class=&#34;link&#34; href=&#34;/compose/how-tos/use-secrets/&#34;&gt;Secrets&lt;/a&gt; 来管理敏感信息。&lt;/p&gt;&#xA;&#xA;&lt;h4 class=&#34; scroll-mt-20 flex items-center gap-2&#34; id=&#34;了解环境变量的优先级&#34;&gt;&#xA;  &lt;a class=&#34;text-black dark:text-white no-underline hover:underline&#34; href=&#34;#%e4%ba%86%e8%a7%a3%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7&#34;&gt;&#xA;    了解环境变量的优先级&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;注意 Docker Compose 如何处理来自不同来源（&lt;code&gt;.env&lt;/code&gt; 文件、shell 变量、Dockerfiles）的&lt;a class=&#34;link&#34; href=&#34;/compose/how-tos/environment-variables/envvars-precedence/&#34;&gt;环境变量优先级&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h4 class=&#34; scroll-mt-20 flex items-center gap-2&#34; id=&#34;使用特定的环境文件&#34;&gt;&#xA;  &lt;a class=&#34;text-black dark:text-white no-underline hover:underline&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e7%89%b9%e5%ae%9a%e7%9a%84%e7%8e%af%e5%a2%83%e6%96%87%e4%bb%b6&#34;&gt;&#xA;    使用特定的环境文件&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;考虑您的应用程序如何适应不同的环境。例如开发、测试、生产，并根据需要使用不同的 &lt;code&gt;.env&lt;/code&gt; 文件。&lt;/p&gt;&#xA;&#xA;&lt;h4 class=&#34; scroll-mt-20 flex items-center gap-2&#34; id=&#34;了解插值&#34;&gt;&#xA;  &lt;a class=&#34;text-black dark:text-white no-underline hover:underline&#34; href=&#34;#%e4%ba%86%e8%a7%a3%e6%8f%92%e5%80%bc&#34;&gt;&#xA;    了解插值&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;理解 compose 文件中&lt;a class=&#34;link&#34; href=&#34;/compose/how-tos/environment-variables/variable-interpolation/&#34;&gt;插值&lt;/a&gt;的工作原理，以实现动态配置。&lt;/p&gt;&#xA;&#xA;&lt;h4 class=&#34; scroll-mt-20 flex items-center gap-2&#34; id=&#34;命令行覆盖&#34;&gt;&#xA;  &lt;a class=&#34;text-black dark:text-white no-underline hover:underline&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e8%a1%8c%e8%a6%86%e7%9b%96&#34;&gt;&#xA;    命令行覆盖&#xA;  &lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;注意您可以在启动容器时从命令行&lt;a class=&#34;link&#34; href=&#34;/compose/how-tos/environment-variables/set-environment-variables/#cli&#34;&gt;覆盖环境变量&lt;/a&gt;。这对于测试或有临时更改时非常有用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building best practices</title>
      <link>/build/building/best-practices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/build/building/best-practices/</guid>
      <description>&lt;h2 class=&#34; scroll-mt-20 flex items-center gap-2&#34; id=&#34;use-multi-stage-builds&#34;&gt;&#xA;  &lt;a class=&#34;text-black dark:text-white no-underline hover:underline&#34; href=&#34;#use-multi-stage-builds&#34;&gt;&#xA;    Use multi-stage builds&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Multi-stage builds let you reduce the size of your final image, by creating a&#xA;cleaner separation between the building of your image and the final output.&#xA;Split your Dockerfile instructions into distinct stages to make sure that the&#xA;resulting output only contains the files that are needed to run the application.&lt;/p&gt;&#xA;&lt;p&gt;Using multiple stages can also let you build more efficiently by executing&#xA;build steps in parallel.&lt;/p&gt;</description>
    </item>
    <item>
      <title>在 WSL 上使用自定义内核</title>
      <link>/desktop/features/wsl/custom-kernels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/desktop/features/wsl/custom-kernels/</guid>
      <description>&lt;p&gt;Docker Desktop 依赖于 Microsoft 分发的默认 WSL 2 Linux 内核中内置的若干内核特性。因此，在 WSL 2 上为 Docker Desktop 使用自定义内核并未得到官方支持，并且可能导致 Docker Desktop 启动或运行时出现问题。&lt;/p&gt;&#xA;&lt;p&gt;然而，在某些情况下，可能有必要运行自定义内核；Docker Desktop 不会阻止其使用，并且一些用户已报告成功使用它们。&lt;/p&gt;&#xA;&lt;p&gt;如果您选择使用自定义内核，建议从 Microsoft 从其&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/WSL2-Linux-Kernel&#34; rel=&#34;noopener&#34;&gt;官方仓库&lt;/a&gt;分发的内核源码树开始，然后在此基础上添加您需要的特性。&lt;/p&gt;&#xA;&lt;p&gt;还建议您：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用与最新 WSL2 分发的内核相同的内核版本。您可以在终端中运行 &lt;code&gt;wsl.exe --system uname -r&lt;/code&gt; 来查找该版本。&lt;/li&gt;&#xA;&lt;li&gt;从 Microsoft 在其&lt;a class=&#34;link&#34; href=&#34;https://github.com/microsoft/WSL2-Linux-Kernel&#34; rel=&#34;noopener&#34;&gt;仓库&lt;/a&gt;提供的默认内核配置开始，并在此基础上添加您需要的特性。&lt;/li&gt;&#xA;&lt;li&gt;确保您的内核构建环境包含 &lt;code&gt;pahole&lt;/code&gt;，并且其版本在相应的内核配置（&lt;code&gt;CONFIG_PAHOLE_VERSION&lt;/code&gt;）中得到正确反映。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>最佳实践</title>
      <link>/desktop/features/wsl/best-practices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/desktop/features/wsl/best-practices/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;始终使用最新版本的 WSL。至少必须使用 WSL 2.1.5 版本，否则 Docker Desktop 可能无法按预期工作。测试、开发和文档均基于最新的内核版本。较旧版本的 WSL 可能导致：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Docker Desktop 定期挂起或在升级时挂起&lt;/li&gt;&#xA;&lt;li&gt;通过 SCCM 部署失败&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;vmmem.exe&lt;/code&gt; 消耗所有内存&lt;/li&gt;&#xA;&lt;li&gt;网络筛选器策略被全局应用，而不是应用到特定对象&lt;/li&gt;&#xA;&lt;li&gt;容器出现 GPU 故障&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为了在绑定挂载文件时获得最佳文件系统性能，建议将源代码和其他需要绑定挂载到 Linux 容器的数据存储在 Linux 文件系统中。例如，在 Linux 文件系统中使用 &lt;code&gt;docker run -v &amp;lt;host-path&amp;gt;:&amp;lt;container-path&amp;gt;&lt;/code&gt;，而不是在 Windows 文件系统中使用。您也可以参考 Microsoft 的&lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/windows/wsl/compare-versions&#34; rel=&#34;noopener&#34;&gt;建议&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仅当原始文件存储在 Linux 文件系统中时，Linux 容器才会收到文件更改事件（“inotify 事件”）。例如，某些 Web 开发工作流依赖 inotify 事件在文件更改时自动重新加载。&lt;/li&gt;&#xA;&lt;li&gt;当文件从 Linux 文件系统绑定挂载时，性能远高于从 Windows 主机远程挂载。因此，请避免使用 &lt;code&gt;docker run -v /mnt/c/users:/users&lt;/code&gt;，其中 &lt;code&gt;/mnt/c&lt;/code&gt; 是从 Windows 挂载的。&lt;/li&gt;&#xA;&lt;li&gt;相反，应从 Linux shell 使用类似 &lt;code&gt;docker run -v ~/my-project:/sources &amp;lt;my-image&amp;gt;&lt;/code&gt; 的命令，其中 &lt;code&gt;~&lt;/code&gt; 会被 Linux shell 展开为 &lt;code&gt;$HOME&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果您担心 &lt;code&gt;docker-desktop-data&lt;/code&gt; 发行版的大小，请查看 &lt;a class=&#34;link&#34; href=&#34;https://learn.microsoft.com/en-us/windows/wsl/disk-space&#34; rel=&#34;noopener&#34;&gt;Windows 内置的 WSL 工具&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
